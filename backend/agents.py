import os
import re
from groq import Groq
import sys
from dotenv import load_dotenv

# Env Loading Logic
search_paths = [
    os.path.join(os.getcwd(), ".env"),
    os.path.join(os.path.dirname(os.path.abspath(__file__)), ".env"),
]

if getattr(sys, 'frozen', False):
    search_paths.append(os.path.join(os.path.dirname(sys.executable), ".env"))

env_path = None
for p in search_paths:
    if os.path.exists(p):
        env_path = p
        break

if env_path:
    load_dotenv(env_path, override=True)
else:
    # Fallback to hardcoded/env var if file not found
    pass

class CodeGeneratorAgent:
    def __init__(self):
        self.api_key = os.getenv("GROQ_API_KEY")
        # Fallback to hardcoded key if env var missing
        if not self.api_key:
            self.api_key = None # Removed hardcoded key for security
            
        if self.api_key:
            self.client = Groq(api_key=self.api_key)
            self.model = "llama-3.3-70b-versatile"
        else:
            self.client = None

    def generate(self, prompt: str, board: str) -> str:
        # 0. Try LLM if available
        if self.client:
            try:
                system_instruction = (
                    "You are Audino, an AI-powered Arduino IDE and code generator.\n"
                    "Your only task is to generate clean, correct, and compilable Arduino code from simple natural language instructions.\n"
                    "Always output valid Arduino C/C++ code.\n"
                    f"Assume Arduino Uno unless specified otherwise. Current Target: {board}.\n"
                    "Always include setup() and loop().\n"
                    "Prefer simplicity over complexity.\n"
                    "Infer sensible defaults when details are missing.\n"
                    "Output only code. No explanations. No markdown."
                )
                completion = self.client.chat.completions.create(
                    messages=[
                        {"role": "system", "content": system_instruction},
                        {"role": "user", "content": prompt}
                    ],
                    model=self.model,
                )
                code = completion.choices[0].message.content
                # Clean up markdown if the model ignores the instruction
                code = code.replace("```cpp", "").replace("```c++", "").replace("```", "").strip()
                return code
            except Exception as e:
                print(f"Groq API Error: {e}")
                return f"// Error: AI Generation Failed.\n// Details: {str(e)}\n// Please check your Internet connection and GROQ_API_KEY."

        prompt = prompt.lower()
        code = ""
        
        # Template Components
        setup_lines = []
        loop_lines = []
        globals_lines = []

        # 1. Blink Logic
        if "blink" in prompt or "led" in prompt:
            pin = 13
            # Extract pin if specified
            pin_match = re.search(r'pin (\d+)', prompt)
            if pin_match:
                pin = int(pin_match.group(1))
            
            setup_lines.append(f"pinMode({pin}, OUTPUT);")
            loop_lines.append(f"digitalWrite({pin}, HIGH);")
            loop_lines.append("delay(1000);")
            loop_lines.append(f"digitalWrite({pin}, LOW);")
            loop_lines.append("delay(1000);")

        # 2. Button Logic
        if "button" in prompt:
            btn_pin = 2
            setup_lines.append(f"pinMode({btn_pin}, INPUT_PULLUP);")
            loop_lines.append(f"if (digitalRead({btn_pin}) == LOW) {{")
            loop_lines.append("  // Button pressed action")
            loop_lines.append("}")

        # 3. Motor Logic
        if "motor" in prompt:
            motor_pin = 9
            setup_lines.append(f"pinMode({motor_pin}, OUTPUT);")
            loop_lines.append(f"analogWrite({motor_pin}, 128); // 50% speed")

        # Fallback
        if not setup_lines:
            if not self.api_key:
                return f"// Error: GROQ_API_KEY Missing.\n// Debug V2: Checked {env_path}. Found={os.path.exists(env_path) if env_path else 'None'}. KeyLen={len(self.api_key) if self.api_key else 0}"
            return "// I'm not sure what you want to build. Try 'Blink LED' or 'Read Button'."

        # Construct Sketch
        code = "// Generated by Aireduino AI (Offline Mode)\n"
        code += "\n".join(globals_lines) + "\n\n"
        code += "void setup() {\n  " + "\n  ".join(setup_lines) + "\n}\n\n"
        code += "void loop() {\n  " + "\n  ".join(loop_lines) + "\n}\n"
        
        return code

class HardwareRulesAgent:
    def check_safety(self, prompt: str, code: str) -> list:
        warnings = []
        prompt = prompt.lower()

        # Motor Safety
        if "motor" in prompt:
            warnings.append("⚠️ SAFETY: Do not power motors directly from Arduino 5V pin! Use an external power supply and share Ground.")
        
        # Pin Conflict (Naive)
        if "pin 0" in code or "pin 1" in code:
            warnings.append("ℹ️ NOTE: Pins 0 and 1 are used for Serial communication. Avoid using them for IO if using Serial.")

        return warnings

# Main Orchestrator
code_agent = CodeGeneratorAgent()
safety_agent = HardwareRulesAgent()

def process_ai_request(prompt: str, board: str):
    # 1. Generate Code
    code = code_agent.generate(prompt, board)
    
    # 2. Safety Check
    warnings = safety_agent.check_safety(prompt, code)
    
    explanation = "I've generated the code for you."
    if warnings:
        explanation += "\n\n" + "\n".join(warnings)
    
    return {"code": code, "explanation": explanation}
